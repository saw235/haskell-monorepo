# BNFC Calculator Example

This example demonstrates how to use BNFC (BNF Converter) to generate Haskell parsers in a Bazel-based Haskell project.

## Overview

BNFC is a tool that generates lexers, parsers, and abstract syntax trees from BNF-style grammar files. This example includes:

- `Calc.cf` - A simple calculator grammar supporting basic arithmetic operations
- `Main.hs` - A REPL-style calculator that uses the generated parser
- `BUILD.bazel` - Bazel build configuration with custom `bnfc_grammar` rule

## Grammar Features

The calculator grammar supports:
- **Integers**: Basic integer literals
- **Arithmetic operations**: Addition (+), subtraction (-), multiplication (*), division (/)
- **Operator precedence**: Multiplication and division have higher precedence than addition and subtraction
- **Parentheses**: For grouping expressions
- **Comments**: Both line comments (//) and block comments (/* */)

## Building and Testing

```bash
# Build the calculator
bazel build //haskell/app/bnfc-example:bnfc-example

# Run the calculator
bazel run //haskell/app/bnfc-example:bnfc-example

# Run QuickCheck property-based tests
bazel test //haskell/app/bnfc-example:quickcheck-tests

# Run QuickCheck tests with output
bazel run //haskell/app/bnfc-example:quickcheck-tests
```

## Usage Examples

```
> 2 + 3
Result: 5

> 2 + 3 * 4
Result: 14

> (2 + 3) * 4
Result: 20

> 10 / 2 - 1
Result: 4
```

## Generated Files

The `bnfc_grammar` rule automatically generates these Haskell modules from `Calc.cf`:

- `AbsCalc.hs` - Abstract syntax tree definitions
- `LexCalc.hs` - Lexer (generated by Alex)
- `ParCalc.hs` - Parser (generated by Happy)
- `PrintCalc.hs` - Pretty printer
- `ErrM.hs` - Error monad

## Technical Details

### Dependencies
- **System tools**: Requires `alex` and `happy` installed via apt (not Stackage versions)
- **Haskell packages**: `base`, `array` (from Stackage)

### BNFC Integration
The project uses a custom Bazel rule `bnfc_grammar` defined in `//tools/bnfc:bnfc.bzl` that:
1. Downloads the BNFC binary for the target platform
2. Generates intermediate `.x` and `.y` files from the grammar
3. Processes them with system-installed Alex and Happy tools
4. Produces the final Haskell modules

### Module Structure
```
Main.hs           -- Entry point and evaluator
├── AbsCalc       -- AST types (Exp, etc.)
├── LexCalc       -- Tokenizer
├── ParCalc       -- Parser (pExp function)
└── ErrM          -- Error handling
```

## Extending the Grammar

To add new features to the calculator:

1. Modify `Calc.cf` with new syntax rules
2. Update the `eval` function in `Main.hs` to handle new AST constructors
3. Rebuild with `bazel build //haskell/app/bnfc-example:bnfc-example`

Example - adding exponentiation:
```bnf
EPow.  Exp3 ::= Exp3 "^" Exp2 ;
```

## QuickCheck Property-Based Testing

The project includes comprehensive QuickCheck tests that verify:

### Parser Properties
- **Round-trip parsing**: `parse(print(expr)) == expr` for valid expressions
- **Basic expression parsing**: Correct parsing of literals and operators
- **Operator precedence**: Multiplication binds tighter than addition

### Evaluator Properties  
- **Arithmetic laws**: Commutativity, associativity, distributivity
- **Identity elements**: Adding 0, multiplying by 1
- **Inverse operations**: Division undoes multiplication
- **Consistency**: Generated expressions evaluate without crashing

### Test Coverage
```
+++ OK, passed 100 tests.           # Evaluator produces finite results
+++ OK, passed 100 tests.           # Addition commutativity  
+++ OK, passed 100 tests.           # Addition associativity
+++ OK, passed 100 tests.           # Multiplication commutativity
+++ OK, passed 100 tests.           # Multiplication associativity
+++ OK, passed 100 tests.           # Multiplication distributivity
+++ OK, passed 100 tests; 765 discarded. # Parser round-trip (non-negative only)
```

The QuickCheck tests use custom `Arbitrary` instances to generate valid AST expressions, automatically testing hundreds of cases to ensure the parser and evaluator work correctly across a wide range of inputs.